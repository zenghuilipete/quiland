package creative.fire.concurrent.bit;

public class ShiftBit {

	public static void main(String[] args) {
		// 2=0000 0010 ->0000 0001
		byte x = 2;
		System.out.println(x >> 1);
		System.out.println(x);// x is not changed.
		System.out.println(x >>= 1);
		System.out.println(x);// x is changed.

		/*
		 * >>运算符作带符号的位移处理，它作位移处理时，会先将值向右移，并在高位填0，
		 * 然后将位移后所空出的高位，全部改成原来的最高位的值（代表正负号的位）。也就是说负的值位移后，仍然是负的值，比如： -10>>2 =-3 -10= 1111 1111
		 * 1111 1111 1111 1111 1111 0110 [10= 1010 取反加1 -10=0101+0001=0110] 右移2位：0011 1111 1111
		 * 1111 1111 1111 1111 1101 结果：1111 1111 1111 1111 1111 1111 1111 1101 [全部填上原本符号位的值：1]
		 * >>>运算符 所作的是无符号的位移处理，它不会将所处理的值的最高位视为正负符号，所以作位移处理时，会直接在空出的高位填入0。
		 * 当我们要作位移的原始值并非代表数值时（例如：表示颜色图素的值，最高位并非正负号），可能就会需要使用此种无符号的位移。比如： -10>>>2=1073741821
		 * -10=1111 1111 1111 1111 1111 1111 1111 0110 (不管原来的“符号”位的值(一长串1)，空上的全部直接填0) 0011 1111
		 * 1111 1111 1111 1111 1111 1101=1037341821 <<运算符
		 * 所作的也是无符号的位移处理，同样地，它不会将所处理的值的最高位视为正负符号，它作位移处理时，会直接左移并在低位填入0。
		 * 所以第二高位以下的位若移到了最高位，该值的正负可能会与原来的不同。 -2147483647<<2=4 -2147483647=1000 0000 0000 0000
		 * 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0100=4 <<<运算符
		 * 恩，当然了，在java里不存在它。
		 */

		System.out.println(-10 >> 2);
		System.out.println(-10 >>> 2);
		System.out.println(1073741821 << 2);
	}

}
